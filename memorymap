Step 2.1 - Text Section:
Prolog
0x4007c4 <readString>:       stp     x19, x20, [sp, #-80]!                      // saves the values of these regs to stack
0x4007c8 <readString+4>:     stp     x21, x30, [sp, #16]                        // to obey callee-saved reg shit
// address of buf is sp + 32 (so it comes after the stuff saved from the regs); '!' at end of first line means sp is updated to sp - 80
First loop setup
0x4007cc <readString+8>:     mov     x19, #0x0                                  // #0      // i = 0
0x4007d0 <readString+12>:    adrp    x21, 0x420000 <__libc_start_main@got.plt>  //  load c library stuff
First loop
0x4007d4 <readString+16>:    mov     w20, w19                                   // save pre-increment value of i into w20
0x4007d8 <readString+20>:    ldr     x0, [x21, #72]                             // getting stdin and putting it in x0 to be used as arg
0x4007dc <readString+24>:    bl      0x400640 <fgetc@plt>                       // call getchar(stdin)
0x4007e0 <readString+28>:    add     x19, x19, #0x1                             // increment i
0x4007e4 <readString+32>:    cmp     w0, #0xa                                   // c == '\n'
// if previous compare is "not equal" (Z == 0), run the next comparison
// else (if Z == 1): then set Z = 1
0x4007e8 <readString+36>:    ccmn    w0, #0x1, #0x4, ne      // ne = any        // c == EOF
0x4007ec <readString+40>:    b.eq    0x400800 <readString+60>  // b.none        // break if Z == 1 (result is equal for either previous comparisons)
0x4007f0 <readString+44>:    add     x1, sp, #0x20                              // buf[i] = c
0x4007f4 <readString+48>:    add     x1, x19, x1                                
0x4007f8 <readString+52>:    sturb   w0, [x1, #-1]                              // stores w0 (char from stdin) to buf[i] (-1 for 0 indexing)
0x4007fc <readString+56>:    b       0x4007d4 <readString+16>
buf[i] = '\0'
0x400800 <readString+60>:    add     x0, sp, #0x20                              // puts address of buf in x0
0x400804 <readString+64>:    strb    wzr, [x0, w20, sxtw]                       // stores \0 into buf[i]
0x400808 <readString+68>:    mov     x0, #0x1                      // #1        // puts 1 in x0
Second loop setup
0x40080c <readString+72>:    adrp    x3, 0x420000 <__libc_start_main@got.plt>
0x400810 <readString+76>:    add     x3, x3, #0x58                              // getting global var name
Second loop
0x400814 <readString+80>:    add     x1, x3, x0                                 // adds 1 to x3, result (name[i + 1]) put in x1
0x400818 <readString+84>:    add     x2, sp, #0x20                              // puts addr of buf in x2
0x40081c <readString+88>:    add     x2, x0, x2                                 // puts addr buf[i] in x2
0x400820 <readString+92>:    ldurb   w2, [x2, #-1]                              // -1 from x2 because of 0 indexing
0x400824 <readString+96>:    sturb   w2, [x1, #-1]                              // stores buf[i] into name[i]
0x400828 <readString+100>:   add     x0, x0, #0x1
0x40082c <readString+104>:   cmp     x0, #0x31                                  // check loop condition
0x400830 <readString+108>:   b.ne    0x400814 <readString+80>  // b.any
Epilog and return
0x400834 <readString+112>:   ldp     x21, x30, [sp, #16]                        // restore callee-saved regs
0x400838 <readString+116>:   ldp     x19, x20, [sp], #80
0x40083c <readString+120>:   ret

Prolog
0x400840 <getName>:  str     x30, [sp, #-16]!                                   // saved callee-saved reg
printf("What is your name?\n");
0x400844 <getName+4>:        adrp    x0, 0x400000                               // load str to be printed
0x400848 <getName+8>:        add     x0, x0, #0x8f8
0x40084c <getName+12>:       bl      0x400670 <puts@plt>                        // printf
readString();
0x400850 <getName+16>:       bl      0x4007c4 <readString>                      // readString
Epilog and return
0x400854 <getName+20>:       ldr     x30, [sp], #16                             // restore callee-saved reg
0x400858 <getName+24>:       ret

Prolog
0x40085c <main>:     stp     x19, x30, [sp, #-16]!
0x400860 <main+4>:   adrp    x19, 0x420000 <__libc_start_main@got.plt>          // get global var name
0x400864 <main+8>:   add     x19, x19, #0x58
mprotect(...);
0x400868 <main+12>:  mov     w2, #0x7                        // #7              // args for mprotect
0x40086c <main+16>:  mov     x1, #0x1                        // #1
0x400870 <main+20>:  and     x0, x19, #0xfffffffffffff000
0x400874 <main+24>:  bl      0x4006a0 <mprotect@plt>
getName();
0x400878 <main+28>:  bl      0x400840 <getName>
if (strcmp(name, "Andrew Appel") != 0) skip assignment to grade
0x40087c <main+32>:  adrp    x1, 0x400000                                       // put "Andrew Appel" into x1
0x400880 <main+36>:  add     x1, x1, #0x910
0x400884 <main+40>:  mov     x0, x19                                            // put inputted name into x0
0x400888 <main+44>:  bl      0x400680 <strcmp@plt>
0x40088c <main+48>:  cbnz    w0, 0x40089c <main+64>                             // if result of comparison != 0 (inputted name is not "Andrew Appel"), skip
grade = 'B';
0x400890 <main+52>:  adrp    x0, 0x420000 <__libc_start_main@got.plt>           // puts global var grade into x0
0x400894 <main+56>:  mov     w1, #0x42                       // #66
0x400898 <main+60>:  strb    w1, [x0, #68]                                      // update grade
printf("%c is your grade.\n", grade);
0x40089c <main+64>:  adrp    x0, 0x420000 <__libc_start_main@got.plt>           // go to where global vars are
0x4008a0 <main+68>:  ldrb    w1, [x0, #68]                                      // load global var grade into w1
0x4008a4 <main+72>:  adrp    x0, 0x400000                                       // go to where strs are
0x4008a8 <main+76>:  add     x0, x0, #0x920                                     // get addr of "%c is your grade.\n"
0x4008ac <main+80>:  bl      0x400690 <printf@plt>
printf("Thank you, %s.\n", name);
0x4008b0 <main+84>:  adrp    x1, 0x420000 <__libc_start_main@got.plt>           // go to where global vars are
0x4008b4 <main+88>:  add     x1, x1, #0x58                                      // get addr of name
0x4008b8 <main+92>:  adrp    x0, 0x400000                                       // go to where strs are (rodata)
0x4008bc <main+96>:  add     x0, x0, #0x938                                     // get addr of "Thank you, %s.\n"
0x4008c0 <main+100>: bl      0x400690 <printf@plt>
Epilog and return 0
0x4008c4 <main+104>: mov     w0, #0x0                        // #0              // setting return to 0
0x4008c8 <main+108>: ldp     x19, x30, [sp], #16
0x4008cc <main+112>: ret

Step 2.2 - Data Section:
Address (in hex) | Content (in hex) | Description
          420044 |               44 | grade

Step 2.3 - BSS Section:
Address (in hex) | Description
          420058 | 'A'   A
          420059 | 'n'   n
          42005a | 'g'   g
          42005b | 'e'   
          42005c | 'l'   &
          42005d | 'i'   
          42005e | 'n'   J
          42005f | 'e'   a
          420060 | ' '   d
          420061 | 'Y'   e
          420062 | 'a'   \0
          420063 | 'n'   0
          420064 | ' '   adr
          420065 | 'a'   
          420066 | 'n'   
          420067 | 'd'   
          420068 | ' '   adr1
          420069 | 'J'
          42006a | 'a'
          42006b | 'd'
          42006c | 'e'   b
          42006d | ' '   
          42006e | 'S'
          42006f | 'c'
          420070 | 'e'   A+ string
          420071 | 'a'   
          420072 | 't'
          420073 | 's'
          420074 | '\0'
          420075 | '\0' // pad until at an addr which is a multiple of 4
          420076 | '\0' // (since instrs must be 4-byte aligned)
          420077 | '\0'
          420078 | 60 // adr x0, grade - load addr of grade
          42007a | fe // note little endian formatting
          42007b | ff
          42007c | 10
          42007d | 21 // mov x1,  #0x41 - get "A"
          42007e | 08
          42007f | 80
          420080 | 52
          420081 | 01 // strb w1, [x0] - store the "A" in grade
          420082 | 00
          420083 | 00
          420084 | 39
          420085 | 06 // b #(0x420078 - 0x40089c) - go to print
          420086 | 82 // statements in main
          420087 | ff
          420088 | 17
          420089 | 78 // address of injected code in bss
          42008a | 00
          42008b | 42
          42008c | 00
          42008d | 00
          42008e | 00
          42008f | 00
          420090 | 00

Step 2.4 - Stack Section:
Offset | Description
     0 | x19
     8 | x20
    16 | x21
    24 | x30
    32 | buf[0]-buf[7]
    40 | buf[8]-buf[15]
    48 | buf[16]-buf[23]
    56 | buf[24]-buf[31]
    64 | buf[32]-buf[39]
    72 | buf[40]-buf[47]
    80 | getName's x30
    // note that c and i are stored in bss since they're uninitialised/
    // zero-initialised